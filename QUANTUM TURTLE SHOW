import turtle
import math
import time
import random
import colorsys  

# --- Configurare turtle ---
t = turtle.Turtle()
t.hideturtle()
t.speed(0)
t.pensize(2)
ecran = turtle.Screen()
ecran.bgcolor("black")
ecran.title("ðŸŒŒ QUANTUM TURTLE SHOW ðŸŒŒ")
turtle.tracer(0, 0)  # Oprim desenarea automatÄƒ pentru vitezÄƒ maximÄƒ


# FuncÈ›ie ajutÄƒtoare pentru culori curcubeu fluide
def get_color(hue):
    # TransformÄƒ un numÄƒr (0.0 - 1.0) Ã®n culoare RGB
    c = colorsys.hsv_to_rgb(hue, 1, 1)
    return c


# === 1ï¸âƒ£ INTRO CIBERNETIC ===
def intro_matrix():
    text = "SYSTEM INITIALIZING..."
    chars = "01"

    # Efect de decriptare
    for i in range(30):
        t.clear()
        t.penup()
        t.goto(0, 0)

        # GenerÄƒm un fundal de numere random stil Matrix
        decoded_text = ""
        for char in text:
            if random.random() > (i / 30):  # ÃŽncet-Ã®ncet apar literele reale
                decoded_text += random.choice(chars)
            else:
                decoded_text += char

        t.color("lime")
        t.write(decoded_text, align="center", font=("Courier", 25, "bold"))
        turtle.update()
        time.sleep(0.08)

    time.sleep(0.5)
    t.clear()


# === 2ï¸âƒ£ TUNELUL PÄ‚TRAT (EFECT 3D) ===
# CreeazÄƒ iluzia cÄƒ intri Ã®n ecran
def tunel_infinit():
    squares = []  # Lista de pÄƒtrate: [mÄƒrime, unghi, nuanÈ›Äƒ_culoare]

    # Pre-populÄƒm tunelul
    for i in range(20):
        squares.append([i * 15, i * 5, i / 20.0])

    for _ in range(120):  # Durata animaÈ›iei
        t.clear()

        # DesenÄƒm fiecare pÄƒtrat din tunel
        for sq in squares:
            size, angle, hue = sq

            t.penup()
            t.goto(0, 0)
            t.setheading(angle)
            t.forward(size)  # Mic truc pentru a centra rotaÈ›ia
            t.right(90)
            t.forward(size)
            t.left(90)
            t.pendown()

            t.color(get_color(hue))
            t.pensize(2 + size / 50)  # Liniile apropiate sunt mai groase

            # DesenÄƒm pÄƒtratul centrat (aproximativ)
            t.penup()
            t.goto(0, 0)
            t.setheading(angle)
            t.forward(size)
            t.right(90)
            t.forward(size)
            t.right(90)
            t.pendown()

            for _ in range(4):
                t.forward(size * 2)
                t.right(90)

            # ActualizÄƒm datele pentru cadrul urmÄƒtor (creÈ™tere + rotaÈ›ie)
            sq[0] += 4  # MÄƒreÈ™te dimensiunea (vine spre noi)
            sq[1] += 2  # RoteÈ™te
            sq[2] += 0.01  # SchimbÄƒ culoarea

            # DacÄƒ pÄƒtratul e prea mare, Ã®l resetÄƒm Ã®n centru (buclÄƒ infinitÄƒ)
            if sq[0] > 400:
                sq[0] = 5

        turtle.update()
        time.sleep(0.02)


# === 3ï¸âƒ£ CURBE LISSAJOUS (NODURI MATEMATICE) ===
# Forme complexe care seamÄƒnÄƒ cu structuri atomice
def noduri_lissajous():
    hue = 0
    phase_x = 0
    phase_y = 0

    for _ in range(150):
        t.clear()
        t.penup()

        # DesenÄƒm o urmÄƒ de puncte
        points = []
        for i in range(0, 360, 2):
            rad = math.radians(i)
            # Formule matematice pentru curbe complexe
            # SchimbÃ¢nd 3 È™i 2 obÈ›ii forme diferite (noduri)
            x = 250 * math.sin(3 * rad + phase_x)
            y = 250 * math.sin(2 * rad + phase_y)
            points.append((x, y))

        # ConectÄƒm punctele
        if points:
            t.goto(points[0])
            t.pendown()
            t.color(get_color(hue))
            t.pensize(3)

            for p in points:
                t.goto(p)
            t.goto(points[0])  # ÃŽnchidem bucla

        # ModificÄƒm parametrii pentru miÈ™care
        phase_x += 0.05
        phase_y += 0.03
        hue += 0.005

        turtle.update()
        time.sleep(0.02)


# === 4ï¸âƒ£ ORGANIC BREATHING (MANDALA CARE RESPIRÄ‚) ===
def mandala_respiratie():
    scale = 0
    growing = True
    rot = 0

    for _ in range(100):
        t.clear()

        # CalculÄƒm factorul de "respiraÈ›ie" (pulse)
        if growing:
            scale += 2
            if scale > 150: growing = False
        else:
            scale -= 2
            if scale < 50: growing = True

        t.penup()
        t.goto(0, 0)
        t.setheading(rot)

        # DesenÄƒm 12 petale
        for i in range(12):
            t.color(get_color((i / 12 + rot / 100) % 1.0))
            t.penup()
            t.goto(0, 0)
            t.setheading(i * 30 + rot)
            t.pendown()

            # DesenÄƒm o petalÄƒ (romb)
            t.forward(scale)
            t.left(45)
            t.forward(scale / 2)
            t.left(135)
            t.forward(scale / 2)
            t.left(45)
            t.forward(scale)

        rot += 2
        turtle.update()
        time.sleep(0.03)


# === 5ï¸âƒ£ RADAR SCANNER (EFECT SONAR) ===
def radar_scan():
    angle = 0
    targets = []  # Puncte "inamice" detectate

    # GenerÄƒm cÃ¢teva È›inte fixe
    for _ in range(5):
        targets.append((random.randint(-200, 200), random.randint(-200, 200)))

    for _ in range(120):  # O rotaÈ›ie completÄƒ e 360, facem mai multe
        t.clear()

        # DesenÄƒm grila radarului
        t.color("darkgreen")
        t.pensize(1)
        t.penup()
        t.goto(0, -250);
        t.pendown();
        t.circle(250)
        t.penup();
        t.goto(0, -150);
        t.pendown();
        t.circle(150)
        t.penup();
        t.goto(0, -50);
        t.pendown();
        t.circle(50)
        t.penup();
        t.goto(0, 250);
        t.pendown();
        t.goto(0, -250)
        t.penup();
        t.goto(-250, 0);
        t.pendown();
        t.goto(250, 0)

        # DesenÄƒm linia care scaneazÄƒ
        t.pensize(3)
        t.color("lime")
        t.penup();
        t.goto(0, 0);
        t.pendown()
        scan_x = 250 * math.cos(math.radians(angle))
        scan_y = 250 * math.sin(math.radians(angle))
        t.goto(scan_x, scan_y)

        # DesenÄƒm "umbra" liniei (fade effect)
        for j in range(1, 20):
            t.color(0, 1 - j / 20, 0)  # Fade to black
            t.penup();
            t.goto(0, 0);
            t.pendown()
            shadow_x = 250 * math.cos(math.radians(angle - j * 2))
            shadow_y = 250 * math.sin(math.radians(angle - j * 2))
            t.goto(shadow_x, shadow_y)

        # DesenÄƒm È›intele dacÄƒ sunt lovite de radar
        for tx, ty in targets:
            # CalculÄƒm unghiul È›intei
            target_angle = math.degrees(math.atan2(ty, tx))
            if target_angle < 0: target_angle += 360

            # NormalizÄƒm unghiul de scanare
            scan_angle_norm = angle % 360

            # DacÄƒ radarul trece peste È›intÄƒ (cu o marjÄƒ de eroare)
            diff = abs(scan_angle_norm - target_angle)
            if diff < 10:
                t.penup()
                t.goto(tx, ty)
                t.dot(10, "red")  # BLIP! Apare roÈ™u
            else:
                t.penup()
                t.goto(tx, ty)
                t.dot(5, "darkgreen")  # Altfel e ascuns/Ã®ntunecat

        angle += 4
        turtle.update()
        time.sleep(0.02)


# === MAIN LOOP ===
intro_matrix()

while True:
    tunel_infinit()
    noduri_lissajous()
    mandala_respiratie()
    radar_scan()
